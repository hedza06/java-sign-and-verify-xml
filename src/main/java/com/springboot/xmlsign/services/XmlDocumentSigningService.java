package com.springboot.xmlsign.services;import com.springboot.xmlsign.utils.X509DataSelector;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Description;import org.springframework.stereotype.Service;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;import javax.xml.crypto.dsig.CanonicalizationMethod;import javax.xml.crypto.dsig.DigestMethod;import javax.xml.crypto.dsig.Reference;import javax.xml.crypto.dsig.SignatureMethod;import javax.xml.crypto.dsig.SignedInfo;import javax.xml.crypto.dsig.Transform;import javax.xml.crypto.dsig.XMLSignature;import javax.xml.crypto.dsig.XMLSignatureFactory;import javax.xml.crypto.dsig.dom.DOMSignContext;import javax.xml.crypto.dsig.dom.DOMValidateContext;import javax.xml.crypto.dsig.keyinfo.KeyInfo;import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;import javax.xml.crypto.dsig.keyinfo.X509Data;import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;import javax.xml.crypto.dsig.spec.TransformParameterSpec;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.StringWriter;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.security.Key;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.PublicKey;import java.security.UnrecoverableKeyException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;@Service@Description("XML Signing and verifying service.")public class XmlDocumentSigningService {    private static final Logger LOGGER = LoggerFactory.getLogger(XmlDocumentSigningService.class);    private static final XMLSignatureFactory xmlSigFactory = XMLSignatureFactory.getInstance("DOM");    private static final String XML_REQUEST_ELEMENT = "RegisterInvoiceRequest";    private static final String XML_REQUEST_ID = "Request";    public static final String XML_SIG_METHOD = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";    @Value("${custom-store.key-store-type}")    private String keyStoreType;    @Value("${custom-store.key-store-path}")    private String keyStorePath;    @Value("${custom-store.key-store-pass}")    private String keyStorePass;    @Value("${custom-store.key-store-alias}")    private String keyStoreAlias;    @Value("${envelope.path}")    private String xmlEnvelopeExample;    @Value("${envelope.transform-path}")    private String transformFilePath;    /**     * Sign XML document from file system.     * Transformation done!     */    public void signXMLDocument()    {        try (            InputStream keyStoreInputStream = new FileInputStream(keyStorePath);            InputStream xmlExampleInputStream = new FileInputStream(xmlEnvelopeExample)        ) {            KeyStore keyStore = KeyStore.getInstance(keyStoreType);            keyStore.load(keyStoreInputStream, keyStorePass.toCharArray());            X509Certificate certificate = (X509Certificate) keyStore.getCertificate(keyStoreAlias);            Key privateKey = keyStore.getKey(keyStoreAlias, keyStorePass.toCharArray());            PublicKey publicKey = certificate.getPublicKey();            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();            documentBuilderFactory.setNamespaceAware(false);            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();            Document document = documentBuilder.parse(xmlExampleInputStream);            NodeList nodeList = document.getElementsByTagName(XML_REQUEST_ELEMENT);            if (nodeList.getLength() == 0) {                throw new Exception(String.format("XML element %s not found", ""));            }            Node nodeToSign = nodeList.item(0);            List<Transform> transformList = new ArrayList<>();            transformList.add(xmlSigFactory.newTransform(Transform.ENVELOPED, (TransformParameterSpec) null));            transformList.add(xmlSigFactory.newTransform(CanonicalizationMethod.EXCLUSIVE, (C14NMethodParameterSpec) null));            Reference reference = xmlSigFactory.newReference('#' + XML_REQUEST_ID,                    xmlSigFactory.newDigestMethod(DigestMethod.SHA256, null),                    transformList, null, null);            SignatureMethod signatureMethod = xmlSigFactory.newSignatureMethod(XML_SIG_METHOD, null);            SignedInfo signedInfo = xmlSigFactory.newSignedInfo(                xmlSigFactory.newCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE, (C14NMethodParameterSpec) null),                signatureMethod, Collections.singletonList(reference));            // Add certificate            List<X509Certificate> certificateList = new ArrayList<>();            certificateList.add(certificate);            // Create key info element            KeyInfoFactory keyInfoFactory = xmlSigFactory.getKeyInfoFactory();            X509Data x509Data = keyInfoFactory.newX509Data(certificateList);            KeyInfo keyInfo = keyInfoFactory.newKeyInfo(Collections.singletonList(x509Data));            // Create context for signing            DOMSignContext dsc = new DOMSignContext(privateKey, nodeToSign);            dsc.setIdAttributeNS((Element) nodeToSign, null, "Id");            // Sign document            XMLSignature signature = xmlSigFactory.newXMLSignature(signedInfo, keyInfo);            signature.sign(dsc);            // Output to string            TransformerFactory transformFactory = TransformerFactory.newInstance();            Transformer transformer = transformFactory.newTransformer();            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");            StringWriter sw = new StringWriter();            StreamResult streamRes = new StreamResult(sw);            transformer.transform(new DOMSource(document), streamRes);            Path path = Paths.get(transformFilePath);            Files.write(path, sw.toString().getBytes());        }        catch (IOException e) {            LOGGER.error("Input|Output exception occurred. Message: {}", e.getMessage());        }        catch (CertificateException | KeyStoreException e) {            LOGGER.error("Certificate exception occurred. Message: {}", e.getMessage());        }        catch (UnrecoverableKeyException e) {            LOGGER.error("Unrecoverable key exception occurred. Message: {}", e.getMessage());        }        catch (NoSuchAlgorithmException e) {            LOGGER.error("No such algorithm exception occurred. Message: {}", e.getMessage());        }        catch (ParserConfigurationException e) {            LOGGER.error("Parser configuration exception occurred. Message: {}", e.getMessage());        }        catch (SAXException e) {            LOGGER.error("SAX Exception occurred. Message: {}", e.getMessage());        }        catch (Exception e) {            LOGGER.error("General error occurred. Message: {}", e.getMessage());        }    }    /**     * Validate signature from XML file     *     * @return boolean value (is valid or not)     */    public boolean validateXMLSignature()    {        try (InputStream transformedXmlInputStream = new FileInputStream(transformFilePath))        {            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();            documentBuilderFactory.setNamespaceAware(true);            Document document = documentBuilderFactory.newDocumentBuilder().parse(transformedXmlInputStream);            // Find Signature element            NodeList nodeList = document.getElementsByTagName("Signature");            if (nodeList.getLength() == 0) {                throw new Exception("Cannot find Signature element");            }            Node signatureNode = nodeList.item(0);            DOMValidateContext validateContext = new DOMValidateContext(new X509DataSelector(), signatureNode);            XMLSignature signature = xmlSigFactory.unmarshalXMLSignature(validateContext);            // Validate the XMLSignature (generated above)            boolean coreValidity = signature.validate(validateContext);            if (!coreValidity)            {                boolean validationStatus = signature.getSignatureValue().validate(validateContext);                LOGGER.warn("signature validation status: {}", validationStatus);                // check the validation status of each Reference                Iterator i = signature.getSignedInfo().getReferences().iterator();                for (int j = 0; i.hasNext(); j++)                {                    boolean refValid = ((Reference) i.next()).validate(validateContext);                    LOGGER.info("ref[{}] validity status. {}", j, refValid);                }                return false;            }            LOGGER.info("Signature passed core validation");            return true;        }        catch (IOException | ParserConfigurationException | SAXException e)        {            LOGGER.error("Validation exception occurred. Message: {}", e.getMessage());            e.printStackTrace();        }        catch (Exception e)        {            LOGGER.error("General validation error occurred. Message: {}", e.getMessage());            e.printStackTrace();        }        return false;    }}